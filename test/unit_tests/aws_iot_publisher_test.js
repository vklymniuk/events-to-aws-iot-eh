'use strict';
require('./bootstrap.js');

const sinon = global.sinon;
const expect = global.expect;

const MockPubSub = require('@vklymniuk/event-handler').MockPubSub;
const AWSIoTEventPublisher = require('../../lib/aws_iot_publisher.js');
const uuidv4 = require('uuid/v4');

describe('AWS IoT Publisher tests ->', function() {
    let mockPubSub;
    let sandbox = sinon.createSandbox();
    let awsIotPublisher;

    beforeEach(() => {
        mockPubSub = new MockPubSub();
        awsIotPublisher = new AWSIoTEventPublisher(mockPubSub);
    });

    afterEach(() => {
        sandbox.restore();
    });

    it('_publishEventToAWSIot is expected to publish Event to a topic generated by getEventPublishTopic', async () => {
        let mockTopic = 'topic/mockTopic';
        awsIotPublisher._getEventPublishTopic = sandbox.stub().returns(mockTopic);
        awsIotPublisher._publishToTopic = sandbox.stub().resolves();
        let mockCtx = {
            EVENT: {
                NAME: 'MOCK_EVENT',
                GROUP_ID: '1234567',
                PAYLOAD: {
                    hello: 'world'
                }
            }
        }
        await awsIotPublisher._publishEventToAWSIot(mockCtx);
        let expectedMessage = JSON.stringify(mockCtx.EVENT);
        expect(awsIotPublisher._publishToTopic.calledWith(expectedMessage, mockTopic)).to.be.true;
    });

    it('_getEventPublishTopic is expected to return events/device/GROUP_ID on target DEVICES and mode BROADCAST', () => {
        awsIotPublisher._mode = 'BROADCAST';
        awsIotPublisher._target = 'DEVICES';
        let mockCtx = {
            EVENT: {
                NAME: 'MOCK_EVENT',
                GROUP_ID: '1234567',
                DEVICE_ID: 'abcd',
                USER_ID: 'gggg',
                PAYLOAD: {
                    hello: 'world'
                }
            }
        }
        let topic = awsIotPublisher._getEventPublishTopic(mockCtx.EVENT);
        expect(topic).to.be.eq('events/device/1234567')
    });

    it('_getEventPublishTopic is expected to return events/device/DEVICE_ID on target DEVICES and mode P2P', () => {
        awsIotPublisher._mode = 'P2P';
        awsIotPublisher._target = 'DEVICES';
        let mockCtx = {
            EVENT: {
                NAME: 'MOCK_EVENT',
                GROUP_ID: '1234567',
                DEVICE_ID: 'abcd',
                USER_ID: 'gggg',
                PAYLOAD: {
                    hello: 'world'
                }
            }
        }
        let topic = awsIotPublisher._getEventPublishTopic(mockCtx.EVENT);
        expect(topic).to.be.eq('events/device/abcd')
    });

    it('_getEventPublishTopic is expected to return events/mobileweb/GROUP_ID on target MOBILE_WEB and mode BROADCAST', () => {
        awsIotPublisher._mode = 'BROADCAST';
        awsIotPublisher._target = 'MOBILE_WEB';
        let mockCtx = {
            EVENT: {
                NAME: 'MOCK_EVENT',
                GROUP_ID: '1234567',
                DEVICE_ID: 'abcd',
                USER_ID: 'gggg',
                PAYLOAD: {
                    hello: 'world'
                }
            }
        }
        let topic = awsIotPublisher._getEventPublishTopic(mockCtx.EVENT);
        expect(topic).to.be.eq('events/mobileweb/1234567')
    });

    it('_getEventPublishTopic is expected to return events/mobileweb/USER_ID on target MOBILE_WEB and mode P2P', () => {
        awsIotPublisher._mode = 'P2P';
        awsIotPublisher._target = 'MOBILE_WEB';
        let mockCtx = {
            EVENT: {
                NAME: 'MOCK_EVENT',
                GROUP_ID: '1234567',
                DEVICE_ID: 'abcd',
                USER_ID: 'gggg',
                PAYLOAD: {
                    hello: 'world'
                }
            }
        }
        let topic = awsIotPublisher._getEventPublishTopic(mockCtx.EVENT);
        expect(topic).to.be.eq('events/mobileweb/gggg')
    });
});